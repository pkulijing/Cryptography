\ifx\PREAMBLE\undefined
\input{preamble}
\begin{document}
\fi
\chapter{Stream Ciphers}
First we would like to provide a precise definition for symmetric ciphers.
\begin{definition}\textbf{(Symmetric Cipher)}
A \textbf{cipher} defined over $(\mathcal{K,M,C})$, in which $\mathcal{K}$ is the set of all possible keys, $\mathcal{M}$ is the set of all possible messages and $\mathcal{C}$ is the set of all possible cipher texts, is a pair of efficient algorithms $(E,D)$ in which the encryption algorithm $E:\mathcal{K\times M}\rightarrow\mathcal{C}$ and the decryption algorithm $D:\mathcal{K\times C}\rightarrow \mathcal{M}$ satisfy the consistence equation
\begin{equation*}
D(k,E(k,m))=m, \forall k\in\mathcal{K},m\in\mathcal{M}.
\end{equation*}
\end{definition}
In practice, $E$ is often randomized, while $D$ is always deterministic.
\section{One Time Pad and Perfect Secrecy}
Now we will introduce our first example of a secure cipher, namely \textbf{the one time pad}. In this case, we have $\mathcal{K=M=C=}\{0,1\}^n$. A key is simply a bit string with the same length as the message text. The cipher text is the XOR of the key and the message, i.e.
\begin{equation*}
c\coloneqq E(k,m)= k\oplus m.
\end{equation*}
To decrypt a cipher text, we simply compute the XOR again, i.e.
\begin{equation*}
m\coloneqq E(k,c)= k\oplus c.
\end{equation*}
Since we have $D(k,E(k,m))=k\oplus(k\oplus m)=(k\oplus k)\oplus m=0\oplus m=m$\footnote{XOR is addition mod 2, thus is associative. Also provable using $a\oplus b=a\cdot\bar{b}+\bar{a}\cdot b$.}, obviously the consistence equation is satisfied. Similarly we have $k=m\oplus c$.

Now let's explain why OTP is a ``good'' cipher.
\begin{definition}\textbf{(Perfect Secrecy)}
A cipher $(E,D)$ over $(\mathcal{K}, \mathcal{M}, \mathcal{C})$ has \textbf{perfect secrecy} if $\forall m_0,m_1\in\mathcal{M}$ with equal length and $\forall c\in\mathcal{C}$, we have 
\begin{equation*}
Pr(E(k,m_0)=c)=Pr(E(k,m_1)=c),
\end{equation*}
in which $k$ is uniform in $\mathcal{K}: k\xleftarrow{R}\mathcal{K}.$
\end{definition}
This definition means that an attacker cannot tell if the message is $m_0, m_1$ or any other message with equal length given only the cipher text. Thus nothing can be learnt about the message from the cipher text, and the cipher is safe from CT-only attack. 

Since $k=c\oplus m$ for OTP, we have $Pr(E(k,m)=c)=\frac{1}{\lvert\mathcal{K}\rvert},\forall c,m$. Hence OTP has perfect secrecy. Nonetheless, the key has to be as long as the message, which makes OTP impractical in actual use. 

Unfortunately, it can be proved that a cipher with perfect secrecy must satisfy $\lvert\mathcal{K}\rvert\ge\lvert\mathcal{M}\rvert$, which means that the length of the key is at least as long as that of the message. So such ciphers are actually hard to use in practice.
\section{Stream Ciphers}
In this section we will try to make OTP practical. The idea is to use a pseudo-random key instead of a random key. 
\begin{definition} \textbf{(PRG)}
A \textbf{pseudo-random generator} is a function $G:\{0,1\}^s\rightarrow\{0,1\}^n$, in which $n\gg s$. 
\end{definition}
$\{0,1\}^s$ is called the \textbf{seed space}. A PRG must be efficiently computable by a deterministic algorithm. A \textbf{stream cipher} just substitutes the random key in OTP with a pseudo-random key generated by a PRG, i.e. with a random seed $k\in\{0,1\}^s$, we have
\begin{align*}
c=E(k,m)=m\oplus G(k)\\
m=D(k,m)=c\oplus G(k)
\end{align*}

Obviously a stream cipher cannot have perfect secrecy because the seed is much shorter than the message. Thus we need a different notion of security, and the security of a stream cipher depends on the PRG used. 

If an attacker is able to compute all bits of $G(k)$ according to the first $i$ bits, then the PRG is not safe from CT-only attacks. For example, an email following the SMTP protocol always starts with ``from:'', thus the attacker can obtain a prefix of $G(k)$ according to the cipher text. We should always use \textbf{unpredictable PRGs} as defined below.
\begin{definition}\textbf{(Predictable PRG)}
A PRG $G$ is \textbf{predictable} if $\exists$ efficient algorithm $\mathcal{A}$ and $i\in[1,n-1]$ s.t. 
\begin{equation*}
Pr\left(\mathcal{A}\left(\left.G(k)\right\vert_{1,\dots,i}\right)=\left.G(k)\right\vert_{i+1}\right)\geq\frac{1}{2}+\epsilon
\end{equation*}
in which $G(k)\vert_{i,...,j}$ is the $i^{th}$ to the $j^{th}$ bit of ${G(k)}$, for some non-negligible $\epsilon$. 
\end{definition}
\begin{definition}\textbf{(Unpredictable PRG)}
A PRG is \textbf{unpredictable} if it is not predictable. 
\end{definition}
An example of predictable PRG is the famous \textbf{linear congruential generator}. A seed $r[0]$ is chosen randomly. Then we calculate
\begin{equation*}
r[i]=(a\cdot r[i-1]+b)\bmod p
\end{equation*}
in which $a,b$ are integer parameters and $p$ is a prime number. In each iteration a few bits of $r[i]$ is outputted. This PRG is easy to predict. 

A variant is the \texttt{random()} function in glibc:
\begin{equation*}
r[i]=(r[i-3]+r[i-31])\%2^{32}
\end{equation*}
and output $r[i]\gg 1$. \texttt{random()} should never be used for cryptography.

A theoretical notion of negligibility is to view $\epsilon$ as a function rather than a scalar. $\epsilon:Z^+\rightarrow R^+$ is non-negligible if $\exists d$ s.t. $\epsilon(\lambda)\geq\frac{1}{\lambda^d}$ is infinitely often, i.e. $\epsilon$ is larger than $\frac{1}{\text{polynomial of }\lambda}$ for many $\lambda$. On the contrary, $\epsilon$ is negligible if $\forall d,\exists \lambda_d$ s.t. $\epsilon(\lambda)\leq\frac{1}{\lambda^d},\forall\lambda\geq\lambda_d.$ For instance, $\frac{1}{2^\lambda}$ is negligible, whilst $\frac{1}{\lambda^{1000}}$ is non-negligible. As a tricky example, 
\[\epsilon(\lambda)=\begin{cases}
\frac{1}{2^\lambda}&\text{for odd }\lambda\\
\frac{1}{\lambda^{1000}}&\text{for even }\lambda
\end{cases}\]
is non-negligible.
\section{Attacks on OTP and Stream Ciphers}
\subsection{Two Time Pad}
A pad should not be used more than once, otherwise the encrypted messages shall be decrypted easily. Suppose two messages $m_1,m_2$ are encrypted using the same pad $PRG(k)$:
\begin{align*}
c_1\leftarrow m_1\oplus PRG(k)\\
c_2\leftarrow m_2\oplus PRG(k)
\end{align*}
If an eavesdropper has intercepted the two cipher texts. By calculating their XOR:
\begin{align*}
c_1\oplus c_2&=(m_1\oplus PRG(k))\oplus(m_2\oplus PRG(k))\\
&=m_1\oplus(PRG(k)\oplus PRG(k))\oplus m_2\\
&=m_1\oplus 0\oplus m_2=m_1\oplus m_2
\end{align*}
The English language and the ASCII encoding has enough redundancy so that $m_1$ and $m_2$ can be easily decoded from $m_1\oplus m_2$. Examples of the use of two time pads are not rare in the real world. In network traffic, if the same key is used for different sessions, as was the case in MS-PPTP and 802.11b WEP, the encryption will be unsafe. Instead, a new key should be used for each session, which is implemented by TLS. And typically it is not wise to use a stream cipher for disk encryption, because once a file is changed, an attacker can easily know where the change happened. 
\subsection{No Integrity}
In general, OTP and stream ciphers provide no integrity at all. In other words, they are \textbf{malleable}. An attacker can modify the cipher text without being noticed by the receiver. In particular, since $(m\oplus k)\oplus p=(m\oplus p)\oplus k$, an attacker can impose a specific effect on the cipher text (i.e. XOR with a specific $p$).
\section{PRG Security}
Let $G:\mathcal{K}\rightarrow\{0,1\}^n$ be a PRG. We will define what it means for the output of $G$ on a random key $\left[k\xleftarrow{R}\mathcal{K}, G(k)\right]$ to be indistinguishable from the output of a truly random sampler on $\{0,1\}^n$ $\left[r\xleftarrow{R}\{0,1\}^n, r\right]$.
\begin{definition}\textbf{(Statistical Test)}
A \textbf{statistical test} is an algorithm $\mathcal{A}$ on $\{0,1\}^n$ that outputs 0 or 1 (i.e. false or true). 
\end{definition}
As a few examples:
\begin{itemize}
\item $\mathcal{A}(x)=1$ iff $\lvert\#0(x)-\#1(x)\rvert\leq 10\sqrt{n}$
\item $\mathcal{A}(x)=1$ iff $\lvert\#00(x)-\frac{n}{4}\rvert\leq 10\sqrt{n}$
\item $\mathcal{A}(x)=1$ iff $\text{max-run-of-0}(x)\leq 10\log_2{n}$\footnote{The expectation of the maximum run of 0 is roughly $\log n$.}
\end{itemize}
\begin{definition}\textbf{(Advantage)}
Let $G:\mathcal{K}\rightarrow\{0,1\}^n$ be a PRG and $\mathcal{A}$ be a statistical test on $\{0,1\}^n$. The \textbf{advantage} of $\mathcal{A}$ relative to $G$ is defined as 
\[Adv_{PRG}[\mathcal{A},G]=\left\lvert\mathop{Pr}\limits_{k\xleftarrow{R}\mathcal{K}}[\mathcal{A}(G(k))=1]-\mathop{Pr}\limits_{r\xleftarrow{R}\{0,1\}^n}[\mathcal{A}(r)=1]\right\rvert.\]
\end{definition}
An advantage takes its value within $[0,1]$. An advantage close to 1 means that $A$ can distinguish the output of $G$ from a random choice, whilst an advantage close to 0 means that $A$ cannot tell the difference. For example, a dummy statistical test that always outputs 0 has 0 advantage for any $G$, meaning that it cannot distinguish any PRG from random choice. 
\begin{definition}\textbf{(Secure PRG)}
A PRG $G$ is called a \textbf{secure PRG} if $\forall$ efficient statistical test  $\mathcal{A}$, $Adv_{PRG}[\mathcal{A},G]$ is negligible.
\end{definition}
Note that the requirement of efficiency of the statistical tests is necessary for this definition to be satisfied. Nonetheless, providing a secure PRG will result in a proof of $P\neq NP$, thus we don't know yet if there exists any secure PRG. 
\begin{theorem}
A secure PRG is unpredictable.
\end{theorem}
\begin{proof}
We will prove its contrapositive, i.e. a predictable PRG is insecure. Recall that a PRG being predictable means the existence of an efficient algorithm $\mathcal{A}$ s.t.
\begin{equation*}
Pr\left(\mathcal{A}\left(\left.G(k)\right\vert_{1,\dots,i}\right)=\left.G(k)\right\vert_{i+1}\right)\geq\frac{1}{2}+\epsilon
\end{equation*}
for a non-negligible $\epsilon$. We define a statistical test $\mathcal{B}(X)$ that outputs 1 iff $\mathcal{A}(X|_{1,\dots,i})=X_{i+1}$. For a random choice, the $(i+1)^{th}$ bit is irrelevant from the first $i$ bits, thus $Pr(\mathcal{B}(r)=1)=\frac{1}{2}.$ However $Pr(\mathcal{B}(G(k))=1)\geq \frac{1}{2}+\epsilon$, hence $Adv_{PRG}[\mathcal{B},G]\geq\epsilon$, which is not negligible and verifies the insecurity of $G$.
for a non-negligible $\epsilon$. We define a statistical test $\mathcal{B}(X)$ that outputs 1 iff $\mathcal{A}(X|_{1,\dots,i})=X_{i+1}$. For a random choice, the $(i+1)^{th}$ bit is irrelevant from the first $i$ bits, thus $Pr(\mathcal{B}(r)=1)=\frac{1}{2}.$ However $Pr(\mathcal{B}(G(k))=1)\geq \frac{1}{2}+\epsilon$, hence $Adv_{PRG}[\mathcal{B},G]\geq\epsilon$, which is not negligible and verifies the insecurity of $G$.
\end{proof}
Actually the converse also holds.
\begin{theorem}
An unpredictable PRG is secure.
\end{theorem}
This theorem means that if next-bit predictors cannot distinguish $G$ from random choice, then no statistical test can. 

Finally let's generalize the definition of computationally indistinguishability.
\begin{definition}
Two distributions $P_1$ and $P_2$ over $\{0,1\}^n$ are \textbf{computationally indistinguishable} if $\forall$ efficient statistical test $\mathcal{A}$, \[\left\lvert\mathop{Pr}\limits_{x\leftarrow P_1}[\mathcal{A}(x)=1]-\mathop{Pr}\limits_{x\leftarrow P_2}[\mathcal{A}(x)=1]\right\rvert\] is negligible. Their relation is denoted as 
\[P_1\approx_p P_2.\]
\end{definition}
According to this definition, a PRG is secure if $\{k\xleftarrow{R}\mathcal{K}:G(k)\}\approx_p r\xleftarrow{R}\{0,1\}^n:r$.
\section{Semantic Security}
In order to claim that a stream cipher using a secure PRG is secure, we have to define what it means for a stream cipher to be secure. In the context of stream ciphers, we assume that an attacker is only capable of obtaining one cipher text. We introduced the concept of perfect secrecy, and revealed that it is a requirement too high to be met in practice. Perfect secrecy requires that $\forall m_0,m_1\in\mathcal{M}$ with equal length, the probability distribution of $E(k,m_0)$ is the same as that of $E(k,m_1)$ for $k\leftarrow\mathcal{K}$ ($\forall m_0,m_1\in\mathcal{M}, k\in\mathcal{K}$ with $\lvert m_0\rvert=\lvert m_1\rvert$, $\{E(k, m_0)\}=\{E(k, m_1)\}$). A looser requirement would be that they be computationally indistinguishable ($\forall m_0,m_1\in\mathcal{M}, k\in\mathcal{K}$ with $\lvert m_0\rvert=\lvert m_1\rvert$, $\{E(k, m_0)\}\approx_p\{E(k, m_1)\}$), which is unfortunately still too strict in practice. Instead of putting the requirement upon arbitrary choices of $m_0$ and $m_1$, we only need $E(k,m_0)$ and $E(k,m_1)$ to be computationally indistinguishable for $m_0$ and $m_1$ that can be exhibited explicitly by an adversary. 

Suppose that an adversary $A$ exhibits two messages $m_0,m_1\in\mathcal{M}$ with equal length, and a challenger (the cipher being challenged) takes both messages, chooses a random key and outputs the cipher text for one of them: $c_b=E(k,m_b)$, in which $b$ is either 0 or 1. The adversary will guess whether the result is the encryption of $m_0$ or $m_1$ and output 0 or 1 respectively($A(c_b)\in\{0,1\}$). Let $EXP(b)$ represent an experiment in which the encryption of $m_b$ is outputted, and define $W_b$ as the event $A(c_b)=1$, i.e. the adversary guessing that $c$ is the encryption of $m_1$ in $EXP(b)$. 
\begin{definition}\textbf{(Semantic Security Advantage)}
With the notations above, the \textbf{semantic security advantage} of the adversary $A$ against the cipher is defined as 
\[Adv_{SS}[A,E]=\left\lvert Pr[W_0]-Pr[W_1]\right\rvert.\]
\end{definition}
Even if only one bit of the plain text can be deduced from the cipher text, the cipher will have SS advantage 1. OTP has SS advantage 0 because $Pr[W_0]=Pr[W_1]$ always holds due to perfect secrecy.
\begin{definition}\textbf{(Semantic Security)}
A cipher $E$ is \textbf{semantically secure} if for all efficient $A$, $Adv_{SS}[A,E]$ is negligible.
\end{definition}

\begin{theorem}
Given a secure PRG $G:\mathcal{K}\rightarrow\{0,1\}^n$, a stream cipher $E$ derived from $G$ is semantically secure. 
\end{theorem} 
Before the proof, let's recall the two types of adversaries involved here. (Suppose $m$ is a message to be encrypted and $G:\mathcal{K}\rightarrow \{0,1\}^n$ is a PRG.)
\begin{itemize}
\item Semantic Security Adversary $A$: acts on an encrypted message, outputs 0 or 1. For a stream cipher built upon a PRG,  $A$ acts on $m\oplus G(k)$.
\item PRG Adversary $B$: a statistical test on $\{0,1\}^n$, outputs 0 or 1, acts on $G(k)$.
\end{itemize}
\begin{proof}
We are going to prove the theorem by proving that $\forall$ semantic security adversary $A$ and two messages $m_0, m_1$ exhibited by it, $\exists$ PRG adversaries (i.e. statistical tests) $B_0,B_1$ s.t.
\[Adv_{SS}[A,E]\leq Adv_{PRG}[B_0,G]+Adv_{PRG}[B_1,G]\]
Since $Adv_{PRG}[B_b,G]$ is negligible (guaranteed by the security of $G$), $Adv_{SS}[A,E]$ will be negligible, which indicates the semantic security of $E$. 

For a PRG adversary $B$, we have 
\[Adv_{PRG}[B,G]=\left\lvert\mathop{Pr}\limits_{r\leftarrow\{0,1\}^n}[B(r)=1]-\mathop{Pr}\limits_{k\leftarrow\mathcal{K}}[B(G(k))=1]\right\rvert.\]

For a given message $m$, an SS adversary $A$ naturally defines a PRG adversary $B$:
\[B(y)=A(m\oplus y), \forall y\in\{0,1\}^n.\]
Hence $\mathop{Pr}\limits_{k\leftarrow\mathcal{K}}[B_b(G(k))=1]=\mathop{Pr}\limits_{k\leftarrow\mathcal{K}}[A(m_b\oplus G(k))=1]=Pr[W_b].$ Similarly, $\mathop{Pr}\limits_{r\leftarrow\{0,1\}^n}[B_b(r)=1]=\mathop{Pr}\limits_{r\leftarrow\{0,1\}^n}[A(m_b\oplus r)=1]=Pr[R_b],$ in which $R_b$ is defined in the same way as $W_b$, but for an OTP, i.e. $Pr[R_b]$ is the probability that the SS adversary $A$ thinks $m_b\oplus r$ is the encryption of $m_1$ and outputs 1. In summary we have 
\[Adv_{PRG}[B_b,G]=\left\lvert Pr[R_b]-Pr[W_b]\right\rvert.\]
Due to the perfect secrecy of OTP, we have $Pr[R_0]=Pr[R_1]$. Thus
\begin{align*}
Adv_{SS}[A,E]&=\left\lvert Pr[W_0]-Pr[W_1]\right\rvert\\
&=\left\lvert Pr[W_0]-Pr[R_0]+Pr[R_1]-Pr[W_1]\right\rvert\\
&\leq\left\lvert Pr[W_0]-Pr[R_0]\right\rvert+\left\lvert Pr[W_1]-Pr[R_1]\right\rvert\\
&=Adv_{PRG}[B_0,G]+Adv_{PRG}[B_1,G].
\end{align*}
\end{proof}
\ifx\PREAMBLE\undefined
\end{document}
\fi